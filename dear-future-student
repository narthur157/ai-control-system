Dear future student/Prof. Miller/???,

	 Contained in this directory is a number of components which work together in ways
	 that have become intuitive to me, but are probably not at all intuitive to you.
	 
	 I've tried to write this code like a library, assuming that somebody else would have
	 to figure it all out in the future. This is my first time writing a "library", though,
	 so it may not be particularly comprehendable.

	 There are a number of resources available to you to help with this.

	 1.) narthur157@gmail.com - this is my e-mail, feel free to ask me questions.
	
	 2.) The README in this directory and in others. Note that the README is in markdown format,
	 which renders nicely if you go to the GitHub page. If there is a README in a folder, going to that
	 folder on GitHub will show the rendered README

	 3.) The javadocs, which should be at narthur157.github.io. These are javadocs generated by eclipse
	 from my comments. There are instructions for re-generating them. I'd recommend keeping these docs
	 reasonably up-to-date. They're only for server-pc at the moment, but they might be helpful for
	 understanding how various components work together.

	 4.) google.com

	 There are a number of things which I wish I had done on this project, but was either too daft or too
	 lazy to implement them

	 1.) Kalman filter for the WheelTimer. This one is a maybe. Kalman filters are weird. If you're into
	 math, you might like it. Otherwise, you don't necessarily need it. The timer is pretty noisy though.

	 2.) Config file. All the parameters for this project should be contained in a singlular location (they're
		 not). I'd suggest storing this as JSON, which is easy to parse (use a library) in every language ever.
		 Some things you might want to make configurable:
		 
		 a.) Motor direction
		 b.) PID constants
		 c.) Neural net structure
		 d.) Indices of columns in data
		 e.) ***Which weight file to use (being able to swap out weights.net and ann.c files for different ANN's)***
		 f.) Everything related to WheelTimer
		 g.) What times to grab future outputs in dataparser.py, and how many future rows to grab.
		 h.) Whether or not eval is doing a search or just returning the result from ANN
		 i.) ??? use your imagination. If you find yourself changing something, then re-running, it should be
			 configurable. 

	 3.) Unit tests. This would actually be a decent way to get into the project, and maintain your sanity. I've found
		 numerous bugs in very foundational parts of this code, and I probably would have saved myself a lot of trouble
		 if I had just written tests. As a guideline, when you're committing code, you should commit unit tests with it.
		 This is just good software engineering, and something I deeply regret not doing.

	 4.) Use git in a reasonable way. Every day that you do significant work there should be at least one commit.
		 Also, you need to set up your own github account and get collaborator access from me or Prof. Miller. 
		 I highly recommend setting up ssh keys help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/
		 Very worth the 5 minutes it takes.

	 Some tips:

	 Use the scripts I wrote. In particular, run is a script that will save you loads of time. Running the project
	 from eclipse sucks a lot. For example, imagine you want to run the neural controller using whatever test is
	 set up in send.java for it, and then use the data from the test to train the neural network (online'ish learning),
	 you can just do `./run -n num_tests -f`. If you weren't using the script, you would need to start the ANN server
	 (eval), then the client program, then the server program, then run dataparser.py on the most recent file in testRuns,
	 then finally RebalanceData.java in server-pc/src/formatting. You should know that all these things are happening,
	 but you shouldn't have to remember the specific details every time you do it if you value your sanity (maybe you don't).

	 Take some time to figure out how the framework works. It's not terribly complex. The server program runs tests, which 
	 extend Test.java and call methods on motor controllers which extend MotorController.java. Tests are "what the robot does", 
	 MotorControllers are "how the robot does it". 

